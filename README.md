## **IntroduÃ§Ã£o**

Bem-vindos ao nosso workshop sobre SQL no **Databricks**. Hoje, vamos explorar os conceitos bÃ¡sicos de bancos de dados e como o Databricks pode ser usado para gerenciar e analisar dados de forma eficiente e escalÃ¡vel. Nosso objetivo Ã© garantir que vocÃª tenha uma base sÃ³lida para aproveitar as prÃ³ximas aulas e trabalhar com SQL em um ambiente de big data.

---

## **Por que Databricks?**

O **Databricks** Ã© uma plataforma unificada de anÃ¡lise de dados que combina o poder do **Apache Spark** com ferramentas avanÃ§adas para manipulaÃ§Ã£o de dados em grande escala. Ele se destaca por:

- **Escalabilidade:** Trabalha com dados estruturados e nÃ£o estruturados em larga escala.
- **Delta Lake:** Uma camada de armazenamento que suporta **ACID transactions**, **versioning** e **time travel**.
- **IntegraÃ§Ã£o:** FÃ¡cil conexÃ£o com diversos serviÃ§os de nuvem, como AWS, Azure e Google Cloud.
- **ColaboraÃ§Ã£o:** Notebooks interativos que permitem equipes colaborarem em tempo real.

AlÃ©m disso, o Databricks facilita o aprendizado e prÃ¡tica com SQL, Python e outras linguagens de anÃ¡lise e engenharia de dados.

---

## **InformaÃ§Ãµes Adicionais**

Aqui estÃ£o alguns recursos para complementar seus estudos:

- **DocumentaÃ§Ã£o Oficial:**  
  [Databricks SQL Documentation](https://docs.databricks.com/sql/index.html)  
  Toda a referÃªncia tÃ©cnica sobre o uso do SQL no Databricks.

- **Comunidade:**  
  [Databricks Community Edition](https://community.databricks.com/)  
  Participe da comunidade e use a versÃ£o gratuita do Databricks para praticar.

---

### Por Que Estudar Databricks e SQL? 

Em um mundo onde os dados sÃ£o o novo petrÃ³leo, dominar ferramentas e linguagens que permitem extrair, transformar e analisar esses dados Ã© essencial para qualquer profissional que deseja se destacar. Estudar **Databricks** e **SQL** nÃ£o Ã© apenas aprender uma nova ferramenta ou linguagem, mas tambÃ©m investir na sua carreira, abrindo portas para oportunidades em setores de tecnologia, negÃ³cios e inovaÃ§Ã£o.

---

### 1. **O Papel dos Dados na Economia Moderna**

Vivemos na era da **transformaÃ§Ã£o digital**, onde quase tudo que fazemos gera dados: compras online, redes sociais, sensores IoT, transaÃ§Ãµes bancÃ¡rias, entre outros. Empresas que conseguem analisar esses dados tÃªm uma vantagem competitiva significativa. Elas podem:

- **Entender o comportamento do consumidor**.
- **Otimizar processos internos**.
- **Antecipar tendÃªncias de mercado**.
- **Aumentar a eficiÃªncia operacional**.

O Databricks e o SQL sÃ£o ferramentas fundamentais para capturar, processar e tirar insights desses dados.

---

### 2. **Por Que Estudar Databricks?**

O **Databricks** Ã© uma plataforma que combina o melhor de dois mundos: **manipulaÃ§Ã£o de grandes volumes de dados** e **anÃ¡lise avanÃ§ada**. Ele se destaca por sua escalabilidade, eficiÃªncia e facilidade de uso. 

#### **Vantagens de Estudar Databricks:**

- **Dominar Big Data:** VocÃª aprende a trabalhar com bilhÃµes de linhas de dados, algo impossÃ­vel em ferramentas tradicionais como o Excel.
- **Facilidade de IntegraÃ§Ã£o:** O Databricks integra-se facilmente a plataformas de nuvem como Azure, AWS e Google Cloud.
- **Habilidades Valorizadas no Mercado:** Empresas lÃ­deres como Amazon, Netflix e Uber usam o Databricks para gerenciar seus dados.
- **PreparaÃ§Ã£o para o Futuro:** Ele suporta inteligÃªncia artificial e aprendizado de mÃ¡quina, Ã¡reas que estÃ£o em rÃ¡pida ascensÃ£o.

---

### 3. **Por Que Estudar SQL?**

O **SQL (Structured Query Language)** Ã© a **linguagem universal de dados**. Ã‰ a porta de entrada para quem deseja trabalhar com bancos de dados relacionais e atÃ© mesmo com tecnologias modernas como Databricks e Apache Spark.

#### **RazÃµes para Aprender SQL:**

- **Base de Dados Universais:** SQL Ã© usado para acessar e manipular bancos de dados em todos os setores.
- **Ampla Aplicabilidade:** De analistas de dados a desenvolvedores e engenheiros de dados, quase todas as profissÃµes tÃ©cnicas usam SQL.
- **Simples e Poderoso:** Ã‰ fÃ¡cil de aprender, mas extremamente versÃ¡til, permitindo desde consultas simples atÃ© anÃ¡lises complexas.
- **Alta Demanda no Mercado:** Profissionais que dominam SQL estÃ£o sempre em alta demanda. Ele Ã© uma habilidade essencial em muitos anÃºncios de vagas de emprego.

---

### 4. **Como Essas Habilidades Valorizam o Profissional**

#### **1. VocÃª se Torna Mais Competitivo**

- O mercado de trabalho estÃ¡ saturado de profissionais que sabem usar Excel, mas hÃ¡ menos pessoas capacitadas em Databricks e SQL.
- Empresas procuram profissionais capazes de lidar com grandes volumes de dados e transformar nÃºmeros em insights acionÃ¡veis.

#### **2. VocÃª AlcanÃ§a Melhores SalÃ¡rios**

- Profissionais de dados, como analistas e engenheiros de dados, estÃ£o entre os mais bem pagos no mercado.
- Segundo relatÃ³rios de mercado, habilidades em SQL e Big Data aumentam o salÃ¡rio mÃ©dio em atÃ© 30%.

#### **3. VocÃª Amplia Sua Versatilidade**

- Com Databricks e SQL, vocÃª pode trabalhar em diversos setores, como tecnologia, saÃºde, finanÃ§as, varejo e indÃºstria.
- Essas habilidades sÃ£o demandadas em startups, grandes corporaÃ§Ãµes e empresas globais.

#### **4. VocÃª Fica Pronto para o Futuro**

- A anÃ¡lise de dados Ã© o futuro. Profissionais que entendem como gerenciar e explorar dados tÃªm papel estratÃ©gico nas organizaÃ§Ãµes.
- Dominar Databricks e SQL prepara vocÃª para Ã¡reas emergentes, como inteligÃªncia artificial, aprendizado de mÃ¡quina e engenharia de dados.

---

### 5. **Exemplo de Impacto no Trabalho**

#### Antes (Com Excel):
- Um analista de dados precisava analisar vendas de um ano. O arquivo tinha 1 milhÃ£o de linhas e era pesado demais para abrir no Excel.
- A soluÃ§Ã£o era dividir os dados em vÃ¡rios arquivos menores, perdendo eficiÃªncia e aumentando o risco de erros.

#### Depois (Com Databricks e SQL):
- O mesmo analista carrega os dados diretamente no Databricks.
- Com algumas linhas de SQL, ele filtra, agrupa e analisa bilhÃµes de registros em minutos.
- O resultado? Economia de tempo, mais precisÃ£o e maior impacto nos negÃ³cios.

---

### 6. **O Que VocÃª Ganha ao Estudar Databricks e SQL**

- **Acesso a Dados em Grande Escala:** VocÃª serÃ¡ capaz de trabalhar com dados de qualquer tamanho, algo que antes parecia impossÃ­vel.
- **Ferramentas Poderosas:** Databricks e SQL permitem anÃ¡lises mais rÃ¡pidas e detalhadas do que o Excel.
- **Habilidades de Destaque:** Poucos profissionais realmente dominam Big Data e SQL, o que faz de vocÃª um recurso valioso.
- **Impacto EstratÃ©gico:** VocÃª nÃ£o serÃ¡ apenas alguÃ©m que analisa dados, mas um profissional que transforma dados em decisÃµes estratÃ©gicas.

---

### ConclusÃ£o

Estudar Databricks e SQL Ã© mais do que aprender novas ferramentas. Ã‰ construir um conjunto de habilidades que o colocarÃ¡ no centro da revoluÃ§Ã£o de dados que estÃ¡ transformando o mundo. Ao dominar essas tecnologias, vocÃª nÃ£o apenas aumenta sua empregabilidade e potencial de ganhos, mas tambÃ©m se posiciona como um solucionador de problemas e inovador dentro de qualquer organizaÃ§Ã£o.

EstÃ¡ pronto para dar esse prÃ³ximo passo em sua carreira? Vamos comeÃ§ar! ğŸš€

---

# IntroduÃ§Ã£o ao Databricks: Um Curso para Quem JÃ¡ Domina Excel

Se vocÃª Ã© um usuÃ¡rio experiente de Excel, jÃ¡ entende bem como organizar, analisar e manipular dados usando planilhas. Agora vamos dar um passo alÃ©m, explorando o Databricks, uma plataforma poderosa e escalÃ¡vel para manipulaÃ§Ã£o de grandes volumes de dados e execuÃ§Ã£o de anÃ¡lises avanÃ§adas. Este curso vai ajudÃ¡-lo a compreender as principais diferenÃ§as entre as ferramentas, os conceitos fundamentais do Databricks e como ele funciona.

---

## O Que Ã© o Databricks?

O **Databricks** Ã© uma plataforma unificada de anÃ¡lise de dados e aprendizado de mÃ¡quina, baseada no **Apache Spark**. Ele foi projetado para processar e analisar grandes volumes de dados de forma escalÃ¡vel, colaborativa e eficiente. Sua interface permite trabalhar com diferentes linguagens, como SQL, Python, Scala e R, integrando dados e anÃ¡lises avanÃ§adas em um Ãºnico lugar.

- **Principais BenefÃ­cios**:
  - Capacidade de processar bilhÃµes de registros.
  - Suporte a **Data Lakes** e mÃºltiplos formatos de dados (Parquet, Delta, CSV, etc.).
  - Interface colaborativa, ideal para equipes.
  - IntegraÃ§Ã£o com nuvens (Azure, AWS, Google Cloud).

---

## DiferenÃ§a Entre Excel e Databricks

Embora ambos sejam usados para manipular dados, o Excel e o Databricks tÃªm conceitos e finalidades diferentes. A tabela a seguir ilustra essas diferenÃ§as:

| **Aspecto**         | **Excel**                             | **Databricks**                          |
|----------------------|---------------------------------------|------------------------------------------|
| **Armazenamento**    | Arquivos locais (XLSX, CSV)           | Bancos de dados e Data Lakes na nuvem    |
| **Tamanho dos Dados**| Limitado (cerca de 1 milhÃ£o de linhas)| Virtualmente ilimitado                   |
| **ColaboraÃ§Ã£o**      | Individual ou em rede limitada        | ColaboraÃ§Ã£o em tempo real na nuvem       |
| **Processamento**    | Local no computador do usuÃ¡rio        | DistribuÃ­do em clusters (nÃ³s e workers)  |
| **Interface**        | Visual e baseada em planilhas         | Baseada em notebooks e queries SQL       |
| **AutomaÃ§Ã£o**        | Suporte a macros e VBA                | Totalmente programÃ¡vel (Python, SQL, etc.) |
| **Finalidade**       | AnÃ¡lises locais e rÃ¡pidas             | AnÃ¡lises escalÃ¡veis e aprendizado de mÃ¡quina |

---

## ComparaÃ§Ã£o de Estruturas: Database vs Excel

No Excel, os dados sÃ£o armazenados e organizados em **planilhas** (worksheets), enquanto no Databricks os dados estÃ£o em **bancos de dados** (databases) e **tabelas**. Vamos entender essa diferenÃ§a:

| **Conceito no Excel** | **Conceito no Databricks** | **DescriÃ§Ã£o**                                                                                     |
|------------------------|---------------------------|---------------------------------------------------------------------------------------------------|
| Planilha               | Tabela                   | Uma tabela no Databricks Ã© como uma planilha no Excel: contÃ©m linhas e colunas.                  |
| Abas                   | Tabelas em um Database   | No Databricks, vÃ¡rias tabelas sÃ£o armazenadas dentro de um banco de dados.                       |
| FÃ³rmulas               | Queries SQL              | No Databricks, usamos SQL para manipular os dados em vez de fÃ³rmulas predefinidas do Excel.      |
| Power Query            | TransformaÃ§Ãµes com SQL   | A funcionalidade de Power Query do Excel Ã© similar Ã s transformaÃ§Ãµes que podemos realizar no Databricks com SQL. |

---

## Arquitetura Cliente-Servidor: Databricks vs Excel

O **Excel** e o **Databricks** tÃªm arquiteturas distintas:

### **Excel: Arquitetura Local**
No Excel, tudo acontece no seu computador:
- O software Ã© instalado localmente.
- Os cÃ¡lculos e o processamento ocorrem no hardware do usuÃ¡rio.
- As limitaÃ§Ãµes sÃ£o impostas pela capacidade do computador (memÃ³ria, CPU, etc.).
  
Essa abordagem Ã© excelente para pequenas anÃ¡lises, mas torna-se inviÃ¡vel para grandes volumes de dados.

---

### **Databricks: Arquitetura Cliente-Servidor**

O Databricks utiliza uma arquitetura distribuÃ­da e baseada em nuvem. Aqui estÃ£o os principais componentes:

1. **Cliente**:
   - A interface web onde vocÃª escreve consultas SQL, cria notebooks ou visualiza resultados.
   - NÃ£o Ã© responsÃ¡vel pelo processamento, mas apenas por enviar as instruÃ§Ãµes ao servidor.

2. **Servidor**:
   - O Databricks processa os dados usando o Apache Spark em um ambiente distribuÃ­do.
   - Isso significa que os dados sÃ£o divididos em blocos e processados simultaneamente por mÃºltiplos workers.

---

### DiferenÃ§as PrÃ¡ticas

| **Aspecto**               | **Excel (Local)**                  | **Databricks (DistribuÃ­do)**                              |
|----------------------------|------------------------------------|----------------------------------------------------------|
| **Processamento**          | No computador do usuÃ¡rio           | Em clusters distribuÃ­dos na nuvem                        |
| **Escalabilidade**         | Limitada Ã  capacidade do hardware  | Altamente escalÃ¡vel, dependendo do nÃºmero de nÃ³s         |
| **Velocidade**             | Reduzida para grandes volumes      | Processamento paralelo acelera a anÃ¡lise                |
| **ColaboraÃ§Ã£o**            | DifÃ­cil em arquivos compartilhados | SimultÃ¢nea, com usuÃ¡rios trabalhando no mesmo cluster    |

---

## Como o Databricks Transforma a AnÃ¡lise de Dados

Se vocÃª jÃ¡ domina Excel, imagine uma planilha sem limites de linhas ou colunas, onde:
- VocÃª pode realizar cÃ¡lculos complexos sem preocupar-se com a performance do seu computador.
- Ã‰ possÃ­vel conectar-se diretamente a fontes de dados na nuvem.
- As anÃ¡lises podem ser feitas de forma colaborativa e escalÃ¡vel.

O Databricks permite que vocÃª execute essas tarefas e muito mais.

### Exemplo PrÃ¡tico de Escalabilidade:
No Excel, abrir um arquivo com 2 milhÃµes de linhas pode travar o computador. No Databricks:
1. VocÃª pode carregar esses dados em uma tabela sem problemas.
2. Consultar apenas os dados necessÃ¡rios usando SQL.
3. Realizar anÃ¡lises em segundos, independentemente do volume.

---

## Resumo

O Databricks Ã© uma evoluÃ§Ã£o natural para quem jÃ¡ domina Excel e deseja trabalhar com:
- **Grandes volumes de dados**.
- **AnÃ¡lises colaborativas**.
- **AutomaÃ§Ã£o e escalabilidade**.

Ao longo deste curso, vamos explorar como migrar seus conhecimentos do Excel para o Databricks e aproveitar todo o poder dessa plataforma para anÃ¡lise de dados moderna.

Pronto para comeÃ§ar? ğŸš€

---

## **Preparando o Ambiente**

### **1. Criar Conta no Databricks Community Edition**
O primeiro passo Ã© configurar sua conta gratuita no Databricks Community Edition. Este ambiente permitirÃ¡ que vocÃª experimente as funcionalidades do Databricks sem custo algum.

1. Acesse o site: [Databricks Community Edition](https://community.databricks.com/).
2. Registre-se usando um e-mail vÃ¡lido.
3. Configure o ambiente, criando um **cluster** para executar os notebooks.

---

Vou criar uma aula Ãºnica e detalhada, abordando todos os tÃ³picos mencionados com exemplos de cÃ³digo, explicaÃ§Ãµes completas e paralelos com o Excel. Aqui estÃ¡ a aula:

---

# Aula: Comandos SQL em Detalhes no Databricks

Nesta aula, exploraremos em profundidade os principais comandos SQL utilizados para consultas e manipulaÃ§Ã£o de dados no Databricks. Nosso objetivo Ã© garantir que vocÃª compreenda como cada comando funciona, suas aplicaÃ§Ãµes e como eles se relacionam com o uso no Excel, um software amplamente utilizado para anÃ¡lises de dados.

---

## IntroduÃ§Ã£o ao Dataset

Utilizaremos o dataset que criamos anteriormente, contendo trÃªs tabelas principais:

- **`vendas`**: InformaÃ§Ãµes sobre transaÃ§Ãµes de vendas.
- **`clientes`**: Dados dos clientes.
- **`produtos`**: Detalhes sobre os produtos vendidos.

Antes de iniciar, vamos revisar as primeiras linhas dessas tabelas para relembrar seus conteÃºdos.

```sql
SELECT * FROM vendas LIMIT 10;
SELECT * FROM clientes LIMIT 10;
SELECT * FROM produtos LIMIT 10;
```

---

# Guia Completo de Comandos SQL no Databricks

Este guia detalhado aborda os comandos SQL mais importantes, desde os mais bÃ¡sicos, como **SELECT**, atÃ© os mais avanÃ§ados, como **JOIN** e **CTE**. A proposta Ã© explicar cada comando com exemplos prÃ¡ticos, paralelos com Excel e dicas para uso no Databricks. Vamos explorar tudo o que vocÃª precisa saber para dominar consultas SQL.

---

# Guia Detalhado de Comandos SQL com Contexto de NegÃ³cio

Este guia detalhado explora os comandos SQL mais usados, abordando como aplicÃ¡-los em cenÃ¡rios reais de negÃ³cios. A proposta Ã© fornecer nÃ£o apenas exemplos de uso tÃ©cnico, mas tambÃ©m o contexto em que cada comando pode ser Ãºtil para anÃ¡lises estratÃ©gicas e operacionais.

---

## **1. SELECT** â€“ **O Ponto de Partida**

O comando **SELECT** Ã© usado para recuperar dados de uma ou mais tabelas, sendo essencial para comeÃ§ar qualquer consulta.

### **Por que usar?**
VocÃª quer visualizar dados brutos ou criar relatÃ³rios baseados em colunas especÃ­ficas. Isso Ã© Ãºtil, por exemplo, para extrair informaÃ§Ãµes de vendas, produtos ou clientes.

### **Exemplo de NegÃ³cio:**
VocÃª precisa verificar o preÃ§o e o nome de todos os produtos disponÃ­veis para otimizar sua estratÃ©gia de precificaÃ§Ã£o.

#### Exemplo 1: Selecionar todas as colunas
```sql
SELECT * FROM produtos;
```
**Contexto de NegÃ³cio:** Visualize todos os detalhes de produtos, como ID, nome, categoria e preÃ§o unitÃ¡rio. Isso Ã© Ãºtil para uma revisÃ£o geral ou para verificar a integridade do banco de dados.

#### Exemplo 2: Selecionar colunas especÃ­ficas
```sql
SELECT id_produto, nome_produto, preco_unitario FROM produtos;
```
**Contexto de NegÃ³cio:** Exiba apenas as informaÃ§Ãµes relevantes, como o nome e o preÃ§o dos produtos, ignorando detalhes como estoque ou categoria.

---

## **2. FROM** â€“ **De Onde os Dados VÃªm**

O comando **FROM** define a origem dos dados. Toda consulta comeÃ§a referenciando uma tabela ou um conjunto de tabelas.

### **Por que usar?**
Sem o **FROM**, o SQL nÃ£o sabe de onde buscar os dados. Pense nele como escolher uma planilha especÃ­fica no Excel.

#### Exemplo: Selecionar dados da tabela `produtos`
```sql
SELECT * FROM produtos;
```
**Contexto de NegÃ³cio:** Analisar os dados completos de uma tabela, como produtos ou clientes, antes de iniciar uma anÃ¡lise detalhada.

---

## **3. COUNT** â€“ **Quantificar os Dados**

O comando **COUNT** Ã© usado para contar o nÃºmero de linhas em um conjunto de dados ou resultado de consulta.

### **Por que usar?**
VocÃª quer entender o volume de dados, como a quantidade de vendas realizadas, clientes cadastrados ou produtos disponÃ­veis.

#### Exemplo 1: Contar o total de produtos cadastrados
```sql
SELECT COUNT(*) AS total_produtos FROM produtos;
```
**Contexto de NegÃ³cio:** Determine quantos produtos vocÃª tem em seu portfÃ³lio para avaliar a diversidade da oferta.

---

## **4. DISTINCT** â€“ **Removendo Duplicatas**

O comando **DISTINCT** retorna valores Ãºnicos em uma ou mais colunas, ajudando a evitar duplicatas nos resultados.

### **Por que usar?**
Quando vocÃª precisa identificar elementos Ãºnicos, como categorias de produtos, cidades de clientes ou mÃ©todos de pagamento.

#### Exemplo 1: Listar todas as categorias de produtos
```sql
SELECT DISTINCT categoria FROM produtos;
```
**Contexto de NegÃ³cio:** Veja todas as categorias de produtos para avaliar a segmentaÃ§Ã£o do portfÃ³lio.

#### Exemplo 2: Listar combinaÃ§Ãµes Ãºnicas de categoria e preÃ§o
```sql
SELECT DISTINCT categoria, preco_unitario FROM produtos;
```
**Contexto de NegÃ³cio:** Analise como os preÃ§os estÃ£o distribuÃ­dos por categoria.

---

## **5. WHERE** â€“ **Filtrando os Dados**

A clÃ¡usula **WHERE** Ã© usada para filtrar registros com base em condiÃ§Ãµes especÃ­ficas.

### **Por que usar?**
Para buscar dados que atendam a critÃ©rios especÃ­ficos, como produtos acima de um certo preÃ§o ou vendas em uma determinada data.

#### Exemplo 1: Produtos com preÃ§o maior que R$100
```sql
SELECT * FROM produtos WHERE preco_unitario > 100;
```
**Contexto de NegÃ³cio:** Identifique produtos premium para estratÃ©gias de marketing focadas em alta margem.

#### Exemplo 2: Produtos da categoria "EletrÃ´nicos"
```sql
SELECT * FROM produtos WHERE categoria = 'EletrÃ´nicos';
```
**Contexto de NegÃ³cio:** Analise produtos eletrÃ´nicos para planejar promoÃ§Ãµes sazonais.

#### Exemplo 3: Contar produtos de uma categoria especÃ­fica
```sql
SELECT COUNT(*) AS total_eletronicos FROM produtos WHERE categoria = 'EletrÃ´nicos';
```
**Contexto de NegÃ³cio:** Identifique o nÃºmero de produtos na categoria "EletrÃ´nicos" para entender o tamanho desse segmento.

---

## **6. LIMIT** â€“ **Restringindo o Volume de Dados**

O **LIMIT** restringe o nÃºmero de linhas retornadas pela consulta, ajudando a focar em uma amostra especÃ­fica.

### **Por que usar?**
Para reduzir o volume de dados analisados inicialmente ou criar relatÃ³rios com os principais resultados.

#### Exemplo: Selecionar os 5
```sql
SELECT * FROM produtos LIMIT 5;
```
**Contexto de NegÃ³cio:** Identifique 5 produtos.

---

## **7. ORDER BY** â€“ **Organizando os Resultados**

A clÃ¡usula **ORDER BY** organiza os resultados com base em uma ou mais colunas.

### **Por que usar?**
Para visualizar os dados de forma ordenada, facilitando a identificaÃ§Ã£o de padrÃµes, como produtos mais baratos ou clientes mais ativos.

#### Exemplo 1: Ordenar produtos por preÃ§o (crescente)
```sql
SELECT * FROM produtos ORDER BY preco_unitario ASC;
```
**Contexto de NegÃ³cio:** Identifique produtos mais acessÃ­veis para estratÃ©gias de vendas baseadas em preÃ§o.

#### Exemplo 2: Ordenar produtos por categoria e preÃ§o (decrescente)
```sql
SELECT * FROM produtos ORDER BY categoria, preco_unitario DESC;
```
**Contexto de NegÃ³cio:** Analise os preÃ§os dentro de cada categoria para identificar padrÃµes ou anomalias.

#### Exemplo 3: Selecionar os 5 produtos mais caros
```sql
SELECT * FROM produtos ORDER BY preco_unitario DESC LIMIT 5;
```
**Contexto de NegÃ³cio:** Identifique os produtos de maior valor para campanhas exclusivas ou anÃ¡lises de rentabilidade.

---

## **8. MIN, MAX, SUM, AVG** â€“ **Resumo de Dados NumÃ©ricos**

Essas funÃ§Ãµes agregadas ajudam a calcular estatÃ­sticas como o menor valor, maior valor, soma e mÃ©dia.

### **Por que usar?**
Para obter uma visÃ£o consolidada dos dados numÃ©ricos, como preÃ§o mÃ©dio, valor total vendido ou produto mais caro.

#### Exemplo 1: Menor e maior preÃ§o de produtos
```sql
SELECT MIN(preco_unitario) AS menor_preco, MAX(preco_unitario) AS maior_preco FROM produtos;
```
**Contexto de NegÃ³cio:** Avalie a amplitude de preÃ§os no portfÃ³lio.

#### Exemplo 2: Soma e mÃ©dia dos preÃ§os de produtos
```sql
SELECT SUM(preco_unitario) AS soma_precos, AVG(preco_unitario) AS media_precos FROM produtos;
```
**Contexto de NegÃ³cio:** Entenda o valor mÃ©dio e total dos produtos disponÃ­veis.

---

## **9. GROUP BY** â€“ **Agrupando Dados**

O **GROUP BY** agrupa registros para aplicar funÃ§Ãµes agregadas.

### **Por que usar?**
Para criar relatÃ³rios baseados em categorias ou segmentos, como vendas por cidade ou preÃ§os mÃ©dios por categoria.

#### Exemplo: PreÃ§o mÃ©dio por categoria
```sql
SELECT categoria, AVG(preco_unitario) AS media_precos FROM produtos GROUP BY categoria;
```
**Contexto de NegÃ³cio:** Compare categorias de produtos com base em seu preÃ§o mÃ©dio.

---

## **10. HAVING** â€“ **Filtrando Grupos**

A clÃ¡usula **HAVING** filtra grupos criados com **GROUP BY**.

### **Por que usar?**
Quando vocÃª precisa aplicar filtros apÃ³s a agregaÃ§Ã£o dos dados.

#### Exemplo: Categorias com preÃ§o mÃ©dio acima de R$100
```sql
SELECT categoria, AVG(preco_unitario) AS media_precos
FROM produtos
GROUP BY categoria
HAVING AVG(preco_unitario) > 100;
```
**Contexto de NegÃ³cio:** Foco em categorias premium para estratÃ©gias de alta margem.

---

## **11. JOIN** â€“ **Combinando Tabelas**

Os **JOINs** sÃ£o uma das partes mais importantes do SQL, usados para combinar dados de duas ou mais tabelas. Isso Ã© essencial em bancos de dados relacionais, onde as informaÃ§Ãµes estÃ£o distribuÃ­das em vÃ¡rias tabelas. Este guia detalha os diferentes tipos de JOIN, com explicaÃ§Ãµes prÃ¡ticas, comparaÃ§Ãµes com Excel e exemplos.

---

## **MÃ³dulo de JOIN: INNER, LEFT e RIGHT**

Os comandos de **JOIN** sÃ£o essenciais para combinar tabelas em SQL. Eles permitem unir informaÃ§Ãµes de diferentes tabelas com base em uma relaÃ§Ã£o lÃ³gica, geralmente definida por uma chave comum, como `id_produto`.

### **1. O que Ã© JOIN?**

**JOIN** conecta duas ou mais tabelas e retorna dados combinados. Dependendo do tipo de JOIN, podemos incluir:
- Somente os registros que tÃªm correspondÃªncia em ambas as tabelas (**INNER JOIN**).
- Todos os registros de uma tabela, mesmo sem correspondÃªncia na outra (**LEFT JOIN** ou **RIGHT JOIN**).

---

### **ComparaÃ§Ã£o com Excel**

No Excel, **JOIN** equivale a:
- **INNER JOIN**: Funciona como **PROCV**, retornando apenas os registros que tÃªm correspondÃªncia.
- **LEFT JOIN**: Similar ao **PROCV**, mas mantÃ©m os valores da tabela base, mesmo que nÃ£o haja correspondÃªncia.
- **RIGHT JOIN**: Invertido, mantendo todos os valores da tabela pesquisada, mesmo sem correspondÃªncia.

---

## **2. Tipos de JOIN e Casos de NegÃ³cio**

A seguir, veremos **INNER JOIN**, **LEFT JOIN** e **RIGHT JOIN**, com exemplos de negÃ³cio detalhados.

---

### **INNER JOIN: Produtos Vendidos e Total de Vendas**

O **INNER JOIN** retorna apenas os registros que tÃªm correspondÃªncia em ambas as tabelas. 

#### **Caso de NegÃ³cio: Total de Vendas por Produto Vendido**

Queremos calcular o total de vendas (em valor) por produto. Isso ajuda a identificar os produtos mais vendidos.

#### **Exemplo de Dados**

**Tabela Produtos (`produtos`):**
| id_produto | nome_produto        | categoria       | preco_unitario |
|------------|---------------------|-----------------|----------------|
| 1          | Notebook Ultra      | EletrÃ´nicos     | 3000.00        |
| 2          | Smartphone Pro      | EletrÃ´nicos     | 2000.00        |
| 3          | Mesa Compacta       | MÃ³veis          | 500.00         |

**Tabela Vendas (`vendas`):**
| id_venda | id_produto | quantidade | data_venda  |
|----------|------------|------------|-------------|
| 1        | 1          | 2          | 2023-01-01  |
| 2        | 2          | 1          | 2023-01-02  |
| 3        | 3          | 5          | 2023-01-03  |

#### **Query**
```sql
SELECT 
    p.id_produto, 
    p.nome_produto, 
    SUM(v.quantidade * p.preco_unitario) AS total_vendas
FROM vendas v
INNER JOIN produtos p ON v.id_produto = p.id_produto
GROUP BY p.id_produto, p.nome_produto
ORDER BY total_vendas DESC;
```

#### **ExplicaÃ§Ã£o**
- **INNER JOIN**: Conecta as tabelas `vendas` e `produtos` com base no `id_produto`.
- **SUM(v.quantidade * p.preco_unitario)**: Calcula o valor total de vendas para cada produto.
- **GROUP BY**: Agrupa os resultados por produto.
- **ORDER BY**: Ordena os produtos com maior receita primeiro.

#### **Resultado**
| id_produto | nome_produto      | total_vendas |
|------------|-------------------|--------------|
| 3          | Mesa Compacta     | 2500.00      |
| 1          | Notebook Ultra    | 6000.00      |
| 2          | Smartphone Pro    | 2000.00      |

---

### **LEFT JOIN: Produtos NÃ£o Vendidos**

O **LEFT JOIN** retorna todos os registros da tabela da esquerda (base) e adiciona os dados correspondentes da tabela da direita. Se nÃ£o houver correspondÃªncia, os valores da tabela direita sÃ£o **NULL**.

#### **Caso de NegÃ³cio: Produtos Nunca Vendidos**

Queremos listar os produtos cadastrados que nunca geraram uma venda. Isso ajuda a identificar itens que precisam de atenÃ§Ã£o em estratÃ©gias de marketing.

#### **Query**
```sql
SELECT 
    p.id_produto, 
    p.nome_produto, 
    p.categoria, 
    p.preco_unitario
FROM produtos p
LEFT JOIN vendas v ON p.id_produto = v.id_produto
WHERE v.id_produto IS NULL;
```

#### **ExplicaÃ§Ã£o**
- **LEFT JOIN**: Inclui todos os produtos, mesmo aqueles sem correspondÃªncia na tabela `vendas`.
- **WHERE v.id_produto IS NULL**: Filtra os produtos que nÃ£o possuem vendas (os valores NULL indicam ausÃªncia de correspondÃªncia).

#### **Resultado**
| id_produto | nome_produto        | categoria       | preco_unitario |
|------------|---------------------|-----------------|----------------|
| 4          | Cadeira ErgonÃ´mica | MÃ³veis          | 600.00         |
| 5          | Monitor Full HD    | EletrÃ´nicos     | 800.00         |

---

### **RIGHT JOIN: Vendas Sem Cadastro no CatÃ¡logo**

O **RIGHT JOIN** mantÃ©m todos os registros da tabela da direita e adiciona os valores da esquerda quando hÃ¡ correspondÃªncia. Usamos para identificar vendas de produtos que nÃ£o estÃ£o cadastrados no catÃ¡logo.

#### **Caso de NegÃ³cio: Produtos NÃ£o Cadastrados**

Queremos identificar os produtos vendidos, mas que nÃ£o constam no catÃ¡logo de produtos.

#### **Query**
```sql
SELECT 
    v.id_produto, 
    COUNT(v.id_venda) AS total_vendas, 
    SUM(v.quantidade) AS total_quantidade
FROM produtos p
RIGHT JOIN vendas v ON p.id_produto = v.id_produto
WHERE p.id_produto IS NULL
GROUP BY v.id_produto;
```

#### **ExplicaÃ§Ã£o**
- **RIGHT JOIN**: Inclui todas as vendas, mesmo que o produto nÃ£o esteja na tabela `produtos`.
- **WHERE p.id_produto IS NULL**: Filtra os produtos que estÃ£o nas vendas, mas nÃ£o no catÃ¡logo.
- **GROUP BY**: Agrupa os resultados por `id_produto`.

#### **Resultado**
| id_produto | total_vendas | total_quantidade |
|------------|--------------|------------------|
| 80         | 1            | 3                |
| 123        | 1            | 5                |
| 444        | 1            | 2                |

---

### **ComparaÃ§Ã£o dos JOINs**

| Tipo de JOIN | Objetivo                                   | Resultado                                                |
|--------------|-------------------------------------------|---------------------------------------------------------|
| **INNER JOIN** | Mostrar apenas os registros com correspondÃªncia | Produtos que foram vendidos                             |
| **LEFT JOIN**  | Mostrar todos os registros da tabela base  | Produtos cadastrados, mesmo sem vendas                  |
| **RIGHT JOIN** | Mostrar todos os registros da tabela relacionada | Vendas de produtos nÃ£o cadastrados                     |

---

### **Contexto de NegÃ³cio**

Esses exemplos ilustram situaÃ§Ãµes prÃ¡ticas no gerenciamento de dados de vendas e produtos:
- **INNER JOIN**: Usado para relatÃ³rios de produtos mais vendidos ou receita total.
- **LEFT JOIN**: Identifica lacunas no desempenho de produtos cadastrados.
- **RIGHT JOIN**: Detecta erros operacionais, como vendas de produtos nÃ£o cadastrados.

Esses JOINs ajudam a garantir a consistÃªncia e a completude dos dados, alÃ©m de apoiar decisÃµes baseadas em anÃ¡lises confiÃ¡veis e detalhadas. ğŸš€
---

## **12. SUBQUERY** â€“ **Consultas Aninhadas**

As **Subqueries** permitem usar o resultado de uma consulta dentro de outra.

### **Por que usar?**
Para anÃ¡lises avanÃ§adas, como identificar produtos acima da mÃ©dia de preÃ§o.

#### Exemplo: Produtos com preÃ§o acima da mÃ©dia
```sql
SELECT * FROM produtos
WHERE preco_unitario > (SELECT AVG(preco_unitario) FROM produtos);
```
**Contexto de NegÃ³cio:** Identifique produtos premium.

---

## **13. CTE** â€“ **Tornando Consultas Mais Organizadas**

As **CTEs** simplificam consultas complexas, dividindo-as em partes mais gerenciÃ¡veis.

### **Por que usar?**
Para tornar anÃ¡lises complexas mais legÃ­veis e reutilizÃ¡veis.

#### Exemplo: Produtos com preÃ§o acima da mÃ©dia usando CTE
```sql
WITH preco_medio AS (
    SELECT AVG(preco_unitario) AS media_precos FROM produtos
)
SELECT * FROM produtos
WHERE preco_unitario > (SELECT media_precos FROM preco_medio);
```
**Contexto de NegÃ³cio:** Torne sua anÃ¡lise mais clara e colaborativa.

---

## **Desafios de NegÃ³cio**

1. **Produtos Mais Vendidos:** Identificar os produtos mais vendidos por quantidade.
2. **MÃªs com Maior Faturamento:** Determinar o perÃ­odo mais lucrativo.
3. **Clientes Mais Lucrativos:** Descobrir os clientes que mais gastam.

Cada desafio pode ser ajustado para se alinhar Ã s necessidades especÃ­ficas do negÃ³cio. ğŸš€