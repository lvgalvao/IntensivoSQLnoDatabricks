## **Introdu√ß√£o**

Bem-vindos ao nosso workshop sobre SQL no **Databricks**. Hoje, vamos explorar os conceitos b√°sicos de bancos de dados e como o Databricks pode ser usado para gerenciar e analisar dados de forma eficiente e escal√°vel. Nosso objetivo √© garantir que voc√™ tenha uma base s√≥lida para aproveitar as pr√≥ximas aulas e trabalhar com SQL em um ambiente de big data.

---

## **Por que Databricks?**

O **Databricks** √© uma plataforma unificada de an√°lise de dados que combina o poder do **Apache Spark** com ferramentas avan√ßadas para manipula√ß√£o de dados em grande escala. Ele se destaca por:

- **Escalabilidade:** Trabalha com dados estruturados e n√£o estruturados em larga escala.
- **Delta Lake:** Uma camada de armazenamento que suporta **ACID transactions**, **versioning** e **time travel**.
- **Integra√ß√£o:** F√°cil conex√£o com diversos servi√ßos de nuvem, como AWS, Azure e Google Cloud.
- **Colabora√ß√£o:** Notebooks interativos que permitem equipes colaborarem em tempo real.

Al√©m disso, o Databricks facilita o aprendizado e pr√°tica com SQL, Python e outras linguagens de an√°lise e engenharia de dados.

---

## **Informa√ß√µes Adicionais**

Aqui est√£o alguns recursos para complementar seus estudos:

- **Documenta√ß√£o Oficial:**  
  [Databricks SQL Documentation](https://docs.databricks.com/sql/index.html)  
  Toda a refer√™ncia t√©cnica sobre o uso do SQL no Databricks.

- **Comunidade:**  
  [Databricks Community Edition](https://community.databricks.com/)  
  Participe da comunidade e use a vers√£o gratuita do Databricks para praticar.

---

### Por Que Estudar Databricks e SQL? 

Em um mundo onde os dados s√£o o novo petr√≥leo, dominar ferramentas e linguagens que permitem extrair, transformar e analisar esses dados √© essencial para qualquer profissional que deseja se destacar. Estudar **Databricks** e **SQL** n√£o √© apenas aprender uma nova ferramenta ou linguagem, mas tamb√©m investir na sua carreira, abrindo portas para oportunidades em setores de tecnologia, neg√≥cios e inova√ß√£o.

---

### 1. **O Papel dos Dados na Economia Moderna**

Vivemos na era da **transforma√ß√£o digital**, onde quase tudo que fazemos gera dados: compras online, redes sociais, sensores IoT, transa√ß√µes banc√°rias, entre outros. Empresas que conseguem analisar esses dados t√™m uma vantagem competitiva significativa. Elas podem:

- **Entender o comportamento do consumidor**.
- **Otimizar processos internos**.
- **Antecipar tend√™ncias de mercado**.
- **Aumentar a efici√™ncia operacional**.

O Databricks e o SQL s√£o ferramentas fundamentais para capturar, processar e tirar insights desses dados.

---

### 2. **Por Que Estudar Databricks?**

O **Databricks** √© uma plataforma que combina o melhor de dois mundos: **manipula√ß√£o de grandes volumes de dados** e **an√°lise avan√ßada**. Ele se destaca por sua escalabilidade, efici√™ncia e facilidade de uso. 

#### **Vantagens de Estudar Databricks:**

- **Dominar Big Data:** Voc√™ aprende a trabalhar com bilh√µes de linhas de dados, algo imposs√≠vel em ferramentas tradicionais como o Excel.
- **Facilidade de Integra√ß√£o:** O Databricks integra-se facilmente a plataformas de nuvem como Azure, AWS e Google Cloud.
- **Habilidades Valorizadas no Mercado:** Empresas l√≠deres como Amazon, Netflix e Uber usam o Databricks para gerenciar seus dados.
- **Prepara√ß√£o para o Futuro:** Ele suporta intelig√™ncia artificial e aprendizado de m√°quina, √°reas que est√£o em r√°pida ascens√£o.

---

### 3. **Por Que Estudar SQL?**

O **SQL (Structured Query Language)** √© a **linguagem universal de dados**. √â a porta de entrada para quem deseja trabalhar com bancos de dados relacionais e at√© mesmo com tecnologias modernas como Databricks e Apache Spark.

#### **Raz√µes para Aprender SQL:**

- **Base de Dados Universais:** SQL √© usado para acessar e manipular bancos de dados em todos os setores.
- **Ampla Aplicabilidade:** De analistas de dados a desenvolvedores e engenheiros de dados, quase todas as profiss√µes t√©cnicas usam SQL.
- **Simples e Poderoso:** √â f√°cil de aprender, mas extremamente vers√°til, permitindo desde consultas simples at√© an√°lises complexas.
- **Alta Demanda no Mercado:** Profissionais que dominam SQL est√£o sempre em alta demanda. Ele √© uma habilidade essencial em muitos an√∫ncios de vagas de emprego.

---

### 4. **Como Essas Habilidades Valorizam o Profissional**

#### **1. Voc√™ se Torna Mais Competitivo**

- O mercado de trabalho est√° saturado de profissionais que sabem usar Excel, mas h√° menos pessoas capacitadas em Databricks e SQL.
- Empresas procuram profissionais capazes de lidar com grandes volumes de dados e transformar n√∫meros em insights acion√°veis.

#### **2. Voc√™ Alcan√ßa Melhores Sal√°rios**

- Profissionais de dados, como analistas e engenheiros de dados, est√£o entre os mais bem pagos no mercado.
- Segundo relat√≥rios de mercado, habilidades em SQL e Big Data aumentam o sal√°rio m√©dio em at√© 30%.

#### **3. Voc√™ Amplia Sua Versatilidade**

- Com Databricks e SQL, voc√™ pode trabalhar em diversos setores, como tecnologia, sa√∫de, finan√ßas, varejo e ind√∫stria.
- Essas habilidades s√£o demandadas em startups, grandes corpora√ß√µes e empresas globais.

#### **4. Voc√™ Fica Pronto para o Futuro**

- A an√°lise de dados √© o futuro. Profissionais que entendem como gerenciar e explorar dados t√™m papel estrat√©gico nas organiza√ß√µes.
- Dominar Databricks e SQL prepara voc√™ para √°reas emergentes, como intelig√™ncia artificial, aprendizado de m√°quina e engenharia de dados.

---

### 5. **Exemplo de Impacto no Trabalho**

#### Antes (Com Excel):
- Um analista de dados precisava analisar vendas de um ano. O arquivo tinha 1 milh√£o de linhas e era pesado demais para abrir no Excel.
- A solu√ß√£o era dividir os dados em v√°rios arquivos menores, perdendo efici√™ncia e aumentando o risco de erros.

#### Depois (Com Databricks e SQL):
- O mesmo analista carrega os dados diretamente no Databricks.
- Com algumas linhas de SQL, ele filtra, agrupa e analisa bilh√µes de registros em minutos.
- O resultado? Economia de tempo, mais precis√£o e maior impacto nos neg√≥cios.

---

### 6. **O Que Voc√™ Ganha ao Estudar Databricks e SQL**

- **Acesso a Dados em Grande Escala:** Voc√™ ser√° capaz de trabalhar com dados de qualquer tamanho, algo que antes parecia imposs√≠vel.
- **Ferramentas Poderosas:** Databricks e SQL permitem an√°lises mais r√°pidas e detalhadas do que o Excel.
- **Habilidades de Destaque:** Poucos profissionais realmente dominam Big Data e SQL, o que faz de voc√™ um recurso valioso.
- **Impacto Estrat√©gico:** Voc√™ n√£o ser√° apenas algu√©m que analisa dados, mas um profissional que transforma dados em decis√µes estrat√©gicas.

---

### Conclus√£o

Estudar Databricks e SQL √© mais do que aprender novas ferramentas. √â construir um conjunto de habilidades que o colocar√° no centro da revolu√ß√£o de dados que est√° transformando o mundo. Ao dominar essas tecnologias, voc√™ n√£o apenas aumenta sua empregabilidade e potencial de ganhos, mas tamb√©m se posiciona como um solucionador de problemas e inovador dentro de qualquer organiza√ß√£o.

Est√° pronto para dar esse pr√≥ximo passo em sua carreira? Vamos come√ßar! üöÄ

---

# Introdu√ß√£o ao Databricks: Um Curso para Quem J√° Domina Excel

Se voc√™ √© um usu√°rio experiente de Excel, j√° entende bem como organizar, analisar e manipular dados usando planilhas. Agora vamos dar um passo al√©m, explorando o Databricks, uma plataforma poderosa e escal√°vel para manipula√ß√£o de grandes volumes de dados e execu√ß√£o de an√°lises avan√ßadas. Este curso vai ajud√°-lo a compreender as principais diferen√ßas entre as ferramentas, os conceitos fundamentais do Databricks e como ele funciona.

---

## O Que √© o Databricks?

O **Databricks** √© uma plataforma unificada de an√°lise de dados e aprendizado de m√°quina, baseada no **Apache Spark**. Ele foi projetado para processar e analisar grandes volumes de dados de forma escal√°vel, colaborativa e eficiente. Sua interface permite trabalhar com diferentes linguagens, como SQL, Python, Scala e R, integrando dados e an√°lises avan√ßadas em um √∫nico lugar.

- **Principais Benef√≠cios**:
  - Capacidade de processar bilh√µes de registros.
  - Suporte a **Data Lakes** e m√∫ltiplos formatos de dados (Parquet, Delta, CSV, etc.).
  - Interface colaborativa, ideal para equipes.
  - Integra√ß√£o com nuvens (Azure, AWS, Google Cloud).

---

## Diferen√ßa Entre Excel e Databricks

Embora ambos sejam usados para manipular dados, o Excel e o Databricks t√™m conceitos e finalidades diferentes. A tabela a seguir ilustra essas diferen√ßas:

| **Aspecto**         | **Excel**                             | **Databricks**                          |
|----------------------|---------------------------------------|------------------------------------------|
| **Armazenamento**    | Arquivos locais (XLSX, CSV)           | Bancos de dados e Data Lakes na nuvem    |
| **Tamanho dos Dados**| Limitado (cerca de 1 milh√£o de linhas)| Virtualmente ilimitado                   |
| **Colabora√ß√£o**      | Individual ou em rede limitada        | Colabora√ß√£o em tempo real na nuvem       |
| **Processamento**    | Local no computador do usu√°rio        | Distribu√≠do em clusters (n√≥s e workers)  |
| **Interface**        | Visual e baseada em planilhas         | Baseada em notebooks e queries SQL       |
| **Automa√ß√£o**        | Suporte a macros e VBA                | Totalmente program√°vel (Python, SQL, etc.) |
| **Finalidade**       | An√°lises locais e r√°pidas             | An√°lises escal√°veis e aprendizado de m√°quina |

---

## Compara√ß√£o de Estruturas: Database vs Excel

No Excel, os dados s√£o armazenados e organizados em **planilhas** (worksheets), enquanto no Databricks os dados est√£o em **bancos de dados** (databases) e **tabelas**. Vamos entender essa diferen√ßa:

| **Conceito no Excel** | **Conceito no Databricks** | **Descri√ß√£o**                                                                                     |
|------------------------|---------------------------|---------------------------------------------------------------------------------------------------|
| Planilha               | Tabela                   | Uma tabela no Databricks √© como uma planilha no Excel: cont√©m linhas e colunas.                  |
| Abas                   | Tabelas em um Database   | No Databricks, v√°rias tabelas s√£o armazenadas dentro de um banco de dados.                       |
| F√≥rmulas               | Queries SQL              | No Databricks, usamos SQL para manipular os dados em vez de f√≥rmulas predefinidas do Excel.      |
| Power Query            | Transforma√ß√µes com SQL   | A funcionalidade de Power Query do Excel √© similar √†s transforma√ß√µes que podemos realizar no Databricks com SQL. |

---

## Arquitetura Cliente-Servidor: Databricks vs Excel

O **Excel** e o **Databricks** t√™m arquiteturas distintas:

### **Excel: Arquitetura Local**
No Excel, tudo acontece no seu computador:
- O software √© instalado localmente.
- Os c√°lculos e o processamento ocorrem no hardware do usu√°rio.
- As limita√ß√µes s√£o impostas pela capacidade do computador (mem√≥ria, CPU, etc.).
  
Essa abordagem √© excelente para pequenas an√°lises, mas torna-se invi√°vel para grandes volumes de dados.

---

### **Databricks: Arquitetura Cliente-Servidor**

O Databricks utiliza uma arquitetura distribu√≠da e baseada em nuvem. Aqui est√£o os principais componentes:

1. **Cliente**:
   - A interface web onde voc√™ escreve consultas SQL, cria notebooks ou visualiza resultados.
   - N√£o √© respons√°vel pelo processamento, mas apenas por enviar as instru√ß√µes ao servidor.

2. **Servidor**:
   - O Databricks processa os dados usando o Apache Spark em um ambiente distribu√≠do.
   - Isso significa que os dados s√£o divididos em blocos e processados simultaneamente por m√∫ltiplos workers.

---

### Diferen√ßas Pr√°ticas

| **Aspecto**               | **Excel (Local)**                  | **Databricks (Distribu√≠do)**                              |
|----------------------------|------------------------------------|----------------------------------------------------------|
| **Processamento**          | No computador do usu√°rio           | Em clusters distribu√≠dos na nuvem                        |
| **Escalabilidade**         | Limitada √† capacidade do hardware  | Altamente escal√°vel, dependendo do n√∫mero de n√≥s         |
| **Velocidade**             | Reduzida para grandes volumes      | Processamento paralelo acelera a an√°lise                |
| **Colabora√ß√£o**            | Dif√≠cil em arquivos compartilhados | Simult√¢nea, com usu√°rios trabalhando no mesmo cluster    |

---

## Como o Databricks Transforma a An√°lise de Dados

Se voc√™ j√° domina Excel, imagine uma planilha sem limites de linhas ou colunas, onde:
- Voc√™ pode realizar c√°lculos complexos sem preocupar-se com a performance do seu computador.
- √â poss√≠vel conectar-se diretamente a fontes de dados na nuvem.
- As an√°lises podem ser feitas de forma colaborativa e escal√°vel.

O Databricks permite que voc√™ execute essas tarefas e muito mais.

### Exemplo Pr√°tico de Escalabilidade:
No Excel, abrir um arquivo com 2 milh√µes de linhas pode travar o computador. No Databricks:
1. Voc√™ pode carregar esses dados em uma tabela sem problemas.
2. Consultar apenas os dados necess√°rios usando SQL.
3. Realizar an√°lises em segundos, independentemente do volume.

---

## Resumo

O Databricks √© uma evolu√ß√£o natural para quem j√° domina Excel e deseja trabalhar com:
- **Grandes volumes de dados**.
- **An√°lises colaborativas**.
- **Automa√ß√£o e escalabilidade**.

Ao longo deste curso, vamos explorar como migrar seus conhecimentos do Excel para o Databricks e aproveitar todo o poder dessa plataforma para an√°lise de dados moderna.

Pronto para come√ßar? üöÄ

---

## **Preparando o Ambiente**

### **1. Criar Conta no Databricks Community Edition**
O primeiro passo √© configurar sua conta gratuita no Databricks Community Edition. Este ambiente permitir√° que voc√™ experimente as funcionalidades do Databricks sem custo algum.

1. Acesse o site: [Databricks Community Edition](https://community.databricks.com/).
2. Registre-se usando um e-mail v√°lido.
3. Configure o ambiente, criando um **cluster** para executar os notebooks.

---

Vou criar uma aula √∫nica e detalhada, abordando todos os t√≥picos mencionados com exemplos de c√≥digo, explica√ß√µes completas e paralelos com o Excel. Aqui est√° a aula:

---

# Aula: Comandos SQL em Detalhes no Databricks

Nesta aula, exploraremos em profundidade os principais comandos SQL utilizados para consultas e manipula√ß√£o de dados no Databricks. Nosso objetivo √© garantir que voc√™ compreenda como cada comando funciona, suas aplica√ß√µes e como eles se relacionam com o uso no Excel, um software amplamente utilizado para an√°lises de dados.

---

## Introdu√ß√£o ao Dataset

Utilizaremos o dataset que criamos anteriormente, contendo tr√™s tabelas principais:

- **`vendas`**: Informa√ß√µes sobre transa√ß√µes de vendas.
- **`clientes`**: Dados dos clientes.
- **`produtos`**: Detalhes sobre os produtos vendidos.

Antes de iniciar, vamos revisar as primeiras linhas dessas tabelas para relembrar seus conte√∫dos.

```sql
SELECT * FROM vendas LIMIT 10;
SELECT * FROM clientes LIMIT 10;
SELECT * FROM produtos LIMIT 10;
```

---

# Guia Completo de Comandos SQL no Databricks

Este guia detalhado aborda os comandos SQL mais importantes, desde os mais b√°sicos, como **SELECT**, at√© os mais avan√ßados, como **JOIN** e **CTE**. A proposta √© explicar cada comando com exemplos pr√°ticos, paralelos com Excel e dicas para uso no Databricks. Vamos explorar tudo o que voc√™ precisa saber para dominar consultas SQL.

---

# Guia Detalhado de Comandos SQL com Contexto de Neg√≥cio

Este guia detalhado explora os comandos SQL mais usados, abordando como aplic√°-los em cen√°rios reais de neg√≥cios. A proposta √© fornecer n√£o apenas exemplos de uso t√©cnico, mas tamb√©m o contexto em que cada comando pode ser √∫til para an√°lises estrat√©gicas e operacionais.

---

## **1. SELECT** ‚Äì **O Ponto de Partida**

O comando **SELECT** √© usado para recuperar dados de uma ou mais tabelas, sendo essencial para come√ßar qualquer consulta.

### **Por que usar?**
Voc√™ quer visualizar dados brutos ou criar relat√≥rios baseados em colunas espec√≠ficas. Isso √© √∫til, por exemplo, para extrair informa√ß√µes de vendas, produtos ou clientes.

### **Exemplo de Neg√≥cio:**
Voc√™ precisa verificar o pre√ßo e o nome de todos os produtos dispon√≠veis para otimizar sua estrat√©gia de precifica√ß√£o.

#### Exemplo 1: Selecionar todas as colunas
```sql
SELECT * FROM produtos;
```
**Contexto de Neg√≥cio:** Visualize todos os detalhes de produtos, como ID, nome, categoria e pre√ßo unit√°rio. Isso √© √∫til para uma revis√£o geral ou para verificar a integridade do banco de dados.

#### Exemplo 2: Selecionar colunas espec√≠ficas
```sql
SELECT id_produto, nome_produto, preco_unitario FROM produtos;
```
**Contexto de Neg√≥cio:** Exiba apenas as informa√ß√µes relevantes, como o nome e o pre√ßo dos produtos, ignorando detalhes como estoque ou categoria.

---

## **2. FROM** ‚Äì **De Onde os Dados V√™m**

O comando **FROM** define a origem dos dados. Toda consulta come√ßa referenciando uma tabela ou um conjunto de tabelas.

### **Por que usar?**
Sem o **FROM**, o SQL n√£o sabe de onde buscar os dados. Pense nele como escolher uma planilha espec√≠fica no Excel.

#### Exemplo: Selecionar dados da tabela `produtos`
```sql
SELECT * FROM produtos;
```
**Contexto de Neg√≥cio:** Analisar os dados completos de uma tabela, como produtos ou clientes, antes de iniciar uma an√°lise detalhada.

---

## **3. COUNT** ‚Äì **Quantificar os Dados**

O comando **COUNT** √© usado para contar o n√∫mero de linhas em um conjunto de dados ou resultado de consulta.

### **Por que usar?**
Voc√™ quer entender o volume de dados, como a quantidade de vendas realizadas, clientes cadastrados ou produtos dispon√≠veis.

#### Exemplo 1: Contar o total de produtos cadastrados
```sql
SELECT COUNT(*) AS total_produtos FROM produtos;
```
**Contexto de Neg√≥cio:** Determine quantos produtos voc√™ tem em seu portf√≥lio para avaliar a diversidade da oferta.

---

## **4. DISTINCT** ‚Äì **Removendo Duplicatas**

O comando **DISTINCT** retorna valores √∫nicos em uma ou mais colunas, ajudando a evitar duplicatas nos resultados.

### **Por que usar?**
Quando voc√™ precisa identificar elementos √∫nicos, como categorias de produtos, cidades de clientes ou m√©todos de pagamento.

#### Exemplo 1: Listar todas as categorias de produtos
```sql
SELECT DISTINCT categoria FROM produtos;
```
**Contexto de Neg√≥cio:** Veja todas as categorias de produtos para avaliar a segmenta√ß√£o do portf√≥lio.

#### Exemplo 2: Listar combina√ß√µes √∫nicas de categoria e pre√ßo
```sql
SELECT DISTINCT categoria, preco_unitario FROM produtos;
```
**Contexto de Neg√≥cio:** Analise como os pre√ßos est√£o distribu√≠dos por categoria.

---

## **5. WHERE** ‚Äì **Filtrando os Dados**

A cl√°usula **WHERE** √© usada para filtrar registros com base em condi√ß√µes espec√≠ficas.

### **Por que usar?**
Para buscar dados que atendam a crit√©rios espec√≠ficos, como produtos acima de um certo pre√ßo ou vendas em uma determinada data.

#### Exemplo 1: Produtos com pre√ßo maior que R$100
```sql
SELECT * FROM produtos WHERE preco_unitario > 100;
```
**Contexto de Neg√≥cio:** Identifique produtos premium para estrat√©gias de marketing focadas em alta margem.

#### Exemplo 2: Produtos da categoria "Eletr√¥nicos"
```sql
SELECT * FROM produtos WHERE categoria = 'Eletr√¥nicos';
```
**Contexto de Neg√≥cio:** Analise produtos eletr√¥nicos para planejar promo√ß√µes sazonais.

#### Exemplo 3: Contar produtos de uma categoria espec√≠fica
```sql
SELECT COUNT(*) AS total_eletronicos FROM produtos WHERE categoria = 'Eletr√¥nicos';
```
**Contexto de Neg√≥cio:** Identifique o n√∫mero de produtos na categoria "Eletr√¥nicos" para entender o tamanho desse segmento.

---

## **6. LIMIT** ‚Äì **Restringindo o Volume de Dados**

O **LIMIT** restringe o n√∫mero de linhas retornadas pela consulta, ajudando a focar em uma amostra espec√≠fica.

### **Por que usar?**
Para reduzir o volume de dados analisados inicialmente ou criar relat√≥rios com os principais resultados.

#### Exemplo: Selecionar os 5
```sql
SELECT * FROM produtos LIMIT 5;
```
**Contexto de Neg√≥cio:** Identifique 5 produtos.

---

## **7. ORDER BY** ‚Äì **Organizando os Resultados**

A cl√°usula **ORDER BY** organiza os resultados com base em uma ou mais colunas.

### **Por que usar?**
Para visualizar os dados de forma ordenada, facilitando a identifica√ß√£o de padr√µes, como produtos mais baratos ou clientes mais ativos.

#### Exemplo 1: Ordenar produtos por pre√ßo (crescente)
```sql
SELECT * FROM produtos ORDER BY preco_unitario ASC;
```
**Contexto de Neg√≥cio:** Identifique produtos mais acess√≠veis para estrat√©gias de vendas baseadas em pre√ßo.

#### Exemplo 2: Ordenar produtos por categoria e pre√ßo (decrescente)
```sql
SELECT * FROM produtos ORDER BY categoria, preco_unitario DESC;
```
**Contexto de Neg√≥cio:** Analise os pre√ßos dentro de cada categoria para identificar padr√µes ou anomalias.

#### Exemplo 3: Selecionar os 5 produtos mais caros
```sql
SELECT * FROM produtos ORDER BY preco_unitario DESC LIMIT 5;
```
**Contexto de Neg√≥cio:** Identifique os produtos de maior valor para campanhas exclusivas ou an√°lises de rentabilidade.

---

## **8. MIN, MAX, SUM, AVG** ‚Äì **Resumo de Dados Num√©ricos**

Essas fun√ß√µes agregadas ajudam a calcular estat√≠sticas como o menor valor, maior valor, soma e m√©dia.

### **Por que usar?**
Para obter uma vis√£o consolidada dos dados num√©ricos, como pre√ßo m√©dio, valor total vendido ou produto mais caro.

#### Exemplo 1: Menor e maior pre√ßo de produtos
```sql
SELECT MIN(preco_unitario) AS menor_preco, MAX(preco_unitario) AS maior_preco FROM produtos;
```
**Contexto de Neg√≥cio:** Avalie a amplitude de pre√ßos no portf√≥lio.

#### Exemplo 2: Soma e m√©dia dos pre√ßos de produtos
```sql
SELECT SUM(preco_unitario) AS soma_precos, AVG(preco_unitario) AS media_precos FROM produtos;
```
**Contexto de Neg√≥cio:** Entenda o valor m√©dio e total dos produtos dispon√≠veis.

---

## **9. GROUP BY** ‚Äì **Agrupando Dados**

O **GROUP BY** agrupa registros para aplicar fun√ß√µes agregadas.

### **Por que usar?**
Para criar relat√≥rios baseados em categorias ou segmentos, como vendas por cidade ou pre√ßos m√©dios por categoria.

#### Exemplo: Pre√ßo m√©dio por categoria
```sql
SELECT categoria, AVG(preco_unitario) AS media_precos FROM produtos GROUP BY categoria;
```
**Contexto de Neg√≥cio:** Compare categorias de produtos com base em seu pre√ßo m√©dio.

---

## **10. HAVING** ‚Äì **Filtrando Grupos**

A cl√°usula **HAVING** filtra grupos criados com **GROUP BY**.

### **Por que usar?**
Quando voc√™ precisa aplicar filtros ap√≥s a agrega√ß√£o dos dados.

#### Exemplo: Categorias com pre√ßo m√©dio acima de R$100
```sql
SELECT categoria, AVG(preco_unitario) AS media_precos
FROM produtos
GROUP BY categoria
HAVING AVG(preco_unitario) > 100;
```
**Contexto de Neg√≥cio:** Foco em categorias premium para estrat√©gias de alta margem.

---

## **11. JOIN** ‚Äì **Combinando Tabelas**

Os **JOINs** s√£o uma das partes mais importantes do SQL, usados para combinar dados de duas ou mais tabelas. Isso √© essencial em bancos de dados relacionais, onde as informa√ß√µes est√£o distribu√≠das em v√°rias tabelas. Este guia detalha os diferentes tipos de JOIN, com explica√ß√µes pr√°ticas, compara√ß√µes com Excel e exemplos.

---

## **M√≥dulo de JOIN: INNER, LEFT e RIGHT**

Os comandos de **JOIN** s√£o essenciais para combinar tabelas em SQL. Eles permitem unir informa√ß√µes de diferentes tabelas com base em uma rela√ß√£o l√≥gica, geralmente definida por uma chave comum, como `id_produto`.

### **1. O que √© JOIN?**

**JOIN** conecta duas ou mais tabelas e retorna dados combinados. Dependendo do tipo de JOIN, podemos incluir:
- Somente os registros que t√™m correspond√™ncia em ambas as tabelas (**INNER JOIN**).
- Todos os registros de uma tabela, mesmo sem correspond√™ncia na outra (**LEFT JOIN** ou **RIGHT JOIN**).

---

### **Compara√ß√£o com Excel**

No Excel, **JOIN** equivale a:
- **INNER JOIN**: Funciona como **PROCV**, retornando apenas os registros que t√™m correspond√™ncia.
- **LEFT JOIN**: Similar ao **PROCV**, mas mant√©m os valores da tabela base, mesmo que n√£o haja correspond√™ncia.
- **RIGHT JOIN**: Invertido, mantendo todos os valores da tabela pesquisada, mesmo sem correspond√™ncia.

---

## **2. Tipos de JOIN e Casos de Neg√≥cio**

A seguir, veremos **INNER JOIN**, **LEFT JOIN** e **RIGHT JOIN**, com exemplos de neg√≥cio detalhados.

---

### **INNER JOIN: Produtos Vendidos e Total de Vendas**

O **INNER JOIN** retorna apenas os registros que t√™m correspond√™ncia em ambas as tabelas. 

#### **Caso de Neg√≥cio: Total de Vendas por Produto Vendido**

Queremos calcular o total de vendas (em valor) por produto. Isso ajuda a identificar os produtos mais vendidos.

#### **Exemplo de Dados**

**Tabela Produtos (`produtos`):**
| id_produto | nome_produto        | categoria       | preco_unitario |
|------------|---------------------|-----------------|----------------|
| 1          | Notebook Ultra      | Eletr√¥nicos     | 3000.00        |
| 2          | Smartphone Pro      | Eletr√¥nicos     | 2000.00        |
| 3          | Mesa Compacta       | M√≥veis          | 500.00         |

**Tabela Vendas (`vendas`):**
| id_venda | id_produto | quantidade | data_venda  |
|----------|------------|------------|-------------|
| 1        | 1          | 2          | 2023-01-01  |
| 2        | 2          | 1          | 2023-01-02  |
| 3        | 3          | 5          | 2023-01-03  |

#### **Query**
```sql
SELECT 
    p.id_produto, 
    p.nome_produto, 
    SUM(v.quantidade * p.preco_unitario) AS total_vendas
FROM vendas v
INNER JOIN produtos p ON v.id_produto = p.id_produto
GROUP BY p.id_produto, p.nome_produto
ORDER BY total_vendas DESC;
```

#### **Explica√ß√£o**
- **INNER JOIN**: Conecta as tabelas `vendas` e `produtos` com base no `id_produto`.
- **SUM(v.quantidade * p.preco_unitario)**: Calcula o valor total de vendas para cada produto.
- **GROUP BY**: Agrupa os resultados por produto.
- **ORDER BY**: Ordena os produtos com maior receita primeiro.

#### **Resultado**
| id_produto | nome_produto      | total_vendas |
|------------|-------------------|--------------|
| 3          | Mesa Compacta     | 2500.00      |
| 1          | Notebook Ultra    | 6000.00      |
| 2          | Smartphone Pro    | 2000.00      |

---

### **LEFT JOIN: Produtos N√£o Vendidos**

O **LEFT JOIN** retorna todos os registros da tabela da esquerda (base) e adiciona os dados correspondentes da tabela da direita. Se n√£o houver correspond√™ncia, os valores da tabela direita s√£o **NULL**.

#### **Caso de Neg√≥cio: Produtos Nunca Vendidos**

Queremos listar os produtos cadastrados que nunca geraram uma venda. Isso ajuda a identificar itens que precisam de aten√ß√£o em estrat√©gias de marketing.

#### **Query**
```sql
SELECT 
    p.id_produto, 
    p.nome_produto, 
    p.categoria, 
    p.preco_unitario
FROM produtos p
LEFT JOIN vendas v ON p.id_produto = v.id_produto
WHERE v.id_produto IS NULL;
```

#### **Explica√ß√£o**
- **LEFT JOIN**: Inclui todos os produtos, mesmo aqueles sem correspond√™ncia na tabela `vendas`.
- **WHERE v.id_produto IS NULL**: Filtra os produtos que n√£o possuem vendas (os valores NULL indicam aus√™ncia de correspond√™ncia).

#### **Resultado**
| id_produto | nome_produto        | categoria       | preco_unitario |
|------------|---------------------|-----------------|----------------|
| 4          | Cadeira Ergon√¥mica | M√≥veis          | 600.00         |
| 5          | Monitor Full HD    | Eletr√¥nicos     | 800.00         |

---

### **RIGHT JOIN: Vendas Sem Cadastro no Cat√°logo**

O **RIGHT JOIN** mant√©m todos os registros da tabela da direita e adiciona os valores da esquerda quando h√° correspond√™ncia. Usamos para identificar vendas de produtos que n√£o est√£o cadastrados no cat√°logo.

#### **Caso de Neg√≥cio: Produtos N√£o Cadastrados**

Queremos identificar os produtos vendidos, mas que n√£o constam no cat√°logo de produtos.

#### **Query**
```sql
SELECT 
    v.id_produto, 
    COUNT(v.id_venda) AS total_vendas, 
    SUM(v.quantidade) AS total_quantidade
FROM produtos p
RIGHT JOIN vendas v ON p.id_produto = v.id_produto
WHERE p.id_produto IS NULL
GROUP BY v.id_produto;
```

#### **Explica√ß√£o**
- **RIGHT JOIN**: Inclui todas as vendas, mesmo que o produto n√£o esteja na tabela `produtos`.
- **WHERE p.id_produto IS NULL**: Filtra os produtos que est√£o nas vendas, mas n√£o no cat√°logo.
- **GROUP BY**: Agrupa os resultados por `id_produto`.

#### **Resultado**
| id_produto | total_vendas | total_quantidade |
|------------|--------------|------------------|
| 80         | 1            | 3                |
| 123        | 1            | 5                |
| 444        | 1            | 2                |

---

### **Compara√ß√£o dos JOINs**

| Tipo de JOIN | Objetivo                                   | Resultado                                                |
|--------------|-------------------------------------------|---------------------------------------------------------|
| **INNER JOIN** | Mostrar apenas os registros com correspond√™ncia | Produtos que foram vendidos                             |
| **LEFT JOIN**  | Mostrar todos os registros da tabela base  | Produtos cadastrados, mesmo sem vendas                  |
| **RIGHT JOIN** | Mostrar todos os registros da tabela relacionada | Vendas de produtos n√£o cadastrados                     |

---

### **Contexto de Neg√≥cio**

Esses exemplos ilustram situa√ß√µes pr√°ticas no gerenciamento de dados de vendas e produtos:
- **INNER JOIN**: Usado para relat√≥rios de produtos mais vendidos ou receita total.
- **LEFT JOIN**: Identifica lacunas no desempenho de produtos cadastrados.
- **RIGHT JOIN**: Detecta erros operacionais, como vendas de produtos n√£o cadastrados.

Esses JOINs ajudam a garantir a consist√™ncia e a completude dos dados, al√©m de apoiar decis√µes baseadas em an√°lises confi√°veis e detalhadas. üöÄ
---

## **12. SUBQUERY** ‚Äì **Consultas Aninhadas**

As **Subqueries** permitem usar o resultado de uma consulta dentro de outra.

### **Por que usar?**
Para an√°lises avan√ßadas, como identificar produtos acima da m√©dia de pre√ßo.

#### Exemplo: Produtos com pre√ßo acima da m√©dia
```sql
SELECT * FROM produtos
WHERE preco_unitario > (SELECT AVG(preco_unitario) FROM produtos);
```
**Contexto de Neg√≥cio:** Identifique produtos premium.

---

## **13. CTE** ‚Äì **Tornando Consultas Mais Organizadas**

As **CTEs** simplificam consultas complexas, dividindo-as em partes mais gerenci√°veis.

### **Por que usar?**
Para tornar an√°lises complexas mais leg√≠veis e reutiliz√°veis.

#### Exemplo: Produtos com pre√ßo acima da m√©dia usando CTE
```sql
WITH preco_medio AS (
    SELECT AVG(preco_unitario) AS media_precos FROM produtos
)
SELECT * FROM produtos
WHERE preco_unitario > (SELECT media_precos FROM preco_medio);
```
**Contexto de Neg√≥cio:** Torne sua an√°lise mais clara e colaborativa.

---

## **Desafios de Neg√≥cio**

1. **Produtos Mais Vendidos:** Identificar os produtos mais vendidos por quantidade.
2. **M√™s com Maior Faturamento:** Determinar o per√≠odo mais lucrativo.
3. **Clientes Mais Lucrativos:** Descobrir os clientes que mais gastam.

Cada desafio pode ser ajustado para se alinhar √†s necessidades espec√≠ficas do neg√≥cio. üöÄ